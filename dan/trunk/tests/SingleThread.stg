group SingleThread;

danModule(frontMatter, imports, decs) ::= <<
// C file generated from Danger source code by the dan compiler
<frontMatter>

// ---------------------------------------
// I m p o r t s
// ---------------------------------------
<imports>

// ---------------------------------------
// D e c l a r a t i o n s
// ---------------------------------------

<decs>
>>

importStmt(library, symbol) ::= <<
// import: library= <library> symbol= <symbol>

>>

attrib(attribId) ::= <<
// [<attribId>]

>>

adornedDec(attribs, dec) ::= <<

// -------------------------------------
// Adorned declaration
// -------------------------------------
// Attribute section:
<attribs>
<dec>

>>

simpleBundleDec(bundleType, 
                channelDecs, 
                wakeWaiting, 
                channelCtors,
                channelOps) ::= <<
// ----------------------------------------------
// <bundleType> channel bundle type

// channel backing store for <bundleType> channel bundle
typedef struct <bundleType>_chans_tag
{
	int is_poisoned; // 0 = false, 1 = true
	<channelDecs>
	
} <bundleType>_chans;

// bundle poison ops

void Poison_<bundleType>(void * chans, scheduler * s)
{
  <bundleType>_chans* rchans = (<bundleType>_chans*)chans;
	rchans->is_poisoned = 1;
	<wakeWaiting>
}

int IsPoisoned_<bundleType>(void * chans)
{
	return ((<bundleType>_chans*)chans)->is_poisoned;
}

bundle_end * <bundleType>_bundleEnd_ctor(bundleEnd * bEnd, <bundleType>_chans * chans)
{
  bEnd->chans = chans;
  bEnd->isPoisoned = IsPoisoned_<bundleType>;
  bEnd->poison = Poison_<bundleType>;
  return bEnd;
}

// <bundleType>_chans constructor
<bundleType>_chans * <bundleType>_chans_ctor(<bundleType>_chans * chans)
{
  chans->is_poisoned = 0;
  <channelCtors>
  return chans;
}

// Channel ops for bundle type <bundleType>

<channelOps>

// End of <bundleType> bundle type


>>


simpleChanWakeupReader(chanName) ::= <<
if( 0 != rchans-><chanName>_reader_waiting)
{
  s->schedule(s, rchans-><chanName>_reader_waiting);
  rchans-><chanName>_reader_waiting = 0;
}

>>

simpleChanWakeupWriter(chanName) ::= <<
if( 0 != rchans-><chanName>_writer_waiting)
{
  s->schedule(s, rchans-><chanName>_writer_waiting);
  rchans-><chanName>_writer_waiting = 0;
}

>>


simpleChanDec(chanType, chanName) ::= <<
// backing store for channel <chanName>
<chanType> <chanName>_value;
unsigned int <chanName>_valid_value; // 0 if invalid
proc * <chanName>_reader_waiting; // reader waiting to synchronize on the channel
proc * <chanName>_writer_waiting; // writer waiting to synchronize on the channel

>>

simpleChanCtor(chanName, defaultValue) ::= <<

chans-><chanName>_value = <defaultValue>;
chans-><chanName>_valid_value = 0;
chans-><chanName>_reader_waiting = 0;
chans-><chanName>_writer_waiting = 0;

>>

simpleChanOps(chanName, chanType, bundleType, wakeupWriter) ::= <<

// Channel ops for channel <chanName> in <bundleType>

// Read op
// returns 0 if it wrote the value and synchronized; 
// 1 if it blocked; and 2 if an exception was thrown
int ChanRead_<bundleType>_<chanName>_0(<bundleType>_chans * chans, 
                                       <chanType> * value, 
                                       char ** exception, 
                                       proc * p, 
                                       scheduler * s)
{
	int ret_val = 2;
	// TODO get the lock
	if(chans->is_poisoned)
	{
		*exception = "channel poison";
	}
	else
	{
		if(chans-><chanName>_valid_value)
		{
			*value = chans-><chanName>_value;
			chans-><chanName>_valid_value = 0;
			<wakeupWriter>
			ret_val = 0;
		}
		else
		{
			chans-><chanName>_reader_waiting = p;
			ret_val = 1;
		}
	}

	// TODO release the lock
	return ret_val;
}

// returns 0 if it got a valid value; 1 if it blocked; and 2 if an exception was thrown
int ChanWrite_BInt_c_0(BInt_chans * chans, int32 value, void ** exception, proc * p, scheduler * s)
{
	int ret_val = 2;
	// TODO get the lock
	if(chans->is_poisoned)
	{
		// TODO make exceptions something other than just plain strings (& null terminated at that!)
		*exception = (void*) "channel poison";
	}
	else
	{
		// TODO right now the writer allways unconditionally writes; allow to withdraw if in ALT
		chans->c_value = value;
		chans->c_valid_value = 1;
		if(chans->reader_waiting != 0)
		{
			s->schedule(s, chans->reader_waiting);
			chans->reader_waiting = 0;
			ret_val = 0;
		}
		else
		{
			chans->writer_waiting = p;
			ret_val = 1;
		}
		
	}

	// TODO release the lock
	return ret_val;
}

// In this case the value has already been written, we're just checking to make sure it has been read
int ChanWriteSync_BInt_c_0(BInt_chans * chans, void ** exception, proc * p, scheduler * s)
{
	int ret_val = 2;
	// TODO get the lock
	if(chans->is_poisoned)
	{
		// TODO make exceptions something other than just plain strings (& null terminated at that!)
		*exception = (void*) "channel poison";
	}
	else
	{
		if(chans->reader_waiting != 0)
		{
			s->schedule(s, chans->reader_waiting);
			chans->reader_waiting = 0;
			ret_val = 0;
		}
		else
		{
			if(chans->c_valid_value == 0)
			{
				ret_val = 0;
			}
			else
			{
				chans->writer_waiting = p;
				ret_val = 1;
			}
		}
	}

	// TODO release the lock
	return ret_val;
}

>>

procDec(procType,
        locals,
        params,
        args,
        initLocals,
        procBodyScratchInit,
        statements,
        cleanup) ::= <<
// ----------------------------------------------
// <procType> PROC type
typedef struct <procType>_locals_tag
{
	<locals>
} <procType>_locals;

typedef struct <procType>_proc_tag
{
    proc                        p;
    <procType>_locals           locals;
} <procType>_proc;

// <procType>_locals constructor
<procType>_locals * <procType>_locals_ctor(<procType>_locals * locals,
    <params; separator=", ">)
{
  <initLocals>
}

// <procType>_proc constructor
<procType>_proc * <procType>_proc_ctor(<procType>_proc * proc,
    <params; separator=", ">)
{
    <procType>_locals_ctor(proc->locals, <args; separator=", ">);
    proc_ctor(proc->p);
}

void <procType>_body(proc * ap, scheduler * s)
{
    <procBodyScratchInit>
	
    <procType>_proc* p = (<procType>_proc*) ap;
	<procType>_locals* locals = &(p->locals);
    if(ap->state != _PS_READY_TO_RUN_)
        restoreState(ap->state);

    <statements>
	
    ap->state = _PS_CLEAN_EXIT_;
EXIT:
    if((ap->state == _PS_EXCEPTION_) || (ap->state == _PS_CLEAN_EXIT_) )
    {
        <cleanup>
    }
}

// End of <procType> PROC type


>>

procDecLite(procType, returnType, params, statements) ::= <<
// TODO use procDecLite for procs that don't have par, fork, or do channel comms
// <returnType> <procType>(<params; separator=", ">)
/* 
    <statements>
*/

>>

defaultCleanup(type, name) ::= <<
// don't need to cleanup <name> of type <type>

>>

bundleEndCleanup(type, name) ::= <<
locals-><name>->poison(locals-><name>->chans, s);

>>

bundleCleanup(type, name) ::= <<
Poison_<type>(&<name>, s);

>>

localValueDec(type, name) ::= <<
<type> <name>;

>>

localByRefDec(type, name) ::= <<
<type> *<name>;

>>

initLocal(name, value) ::= <<
locals-><name> = <value>; 

>>


constructLocal(type) ::= <<
// TODO construct local <type>

>>



valueParam(type, name) ::= "<type> <name>"

refParam(type, name) ::= "<type> *<name>"


ifStatement(condition, statements) ::= <<
if ( <condition> )
{
    <statements>
}

>>

elseIfStatement(condition, statements) ::= <<
else if ( <condition> )
{
    <statements>
}

>>

elseStatement(condition, statements) ::= <<
else
{
    <statments>
}

>>

whileStatement(condition, statements) ::= <<
while (<condition>)
{
    <statements>
}

>>

receiveStatement(procType, chanr, target, labelNum, targetCleanup) ::= <<
<targetCleanup>
saveState(ap->state, <procType>_S<labelNum>);
<target> = locals-><chanr>->read( locals-><chanr>->channel, &(locals-><target>), &ap->exception, ap, s);
switch(result)
{
case 0 : // read value
    printf("<procType>: read value %d from <chanr>\n", locals-><target>);
    break;
case 1 : // blocked
    // let it read again
    goto EXIT;
case 2 : // exception
    ap->state = _PS_EXCEPTION_;
    goto EXIT;
default:
    printf("unexpected result from read on <chanr> in <procType>_body: %d\n", result);
    ap->state = _PS_EXCEPTION_;
    ap->exception = "unexpected result from read on <chanr> in <procType>_body";
    goto EXIT;
}

>>

sendStatement(procType, chanw, source, labelNum, sourceCleanup) ::= <<
result = locals-><chanw>->write( locals-><chanw>->channel, locals-><source>, (void **) &ap->exception, ap, s);
switch(result)
{
case 0 : // wrote value
    printf("<procType>: wrote <source> to <chanw>\n", locals-><source>);
    break;
case 1 : // blocked
    saveState(ap->state, <procType>_S<labelNum>);
    if(result == 1)
        goto EXIT;
    result = locals-><chanw>->writeHandshake( locals-><chanw>->channel, (void **) &ap->exception, ap, s);
    switch(result)
    {
    case 0 : // wrote value
        printf("<procType>: wrote <source> to <chanw>\n", locals-><source>);
        break;
    case 1 : // blocked
        goto EXIT;
    case 2 : // exception
        p->state = _PS_EXCEPTION_;
        goto EXIT;
    default:
        printf("unexpected result from write to <chanw> in <procType>_body: %d\n", result);
        ap->state = _PS_EXCEPTION_;
        ap->exception = "unexpected result from write to <chanw> in <procType>_body";
        goto EXIT;
    }
    break;
case 2 : // exception
    ap->state = _PS_EXCEPTION_;
    goto EXIT;
default:
    printf("unexpected result from write to <chanw> in <procType>_body: %d\n", result);
    ap->state = _PS_EXCEPTION_;
    ap->exception = "unexpected result from write to <chanw> in <procType>_body";
    goto EXIT;
}
<sourceCleanup>

>>

assignmentStatement(target, targetCleanup, source) ::= <<
locals-><target> = <source>;
<targetCleanup>

>>

binaryOp(left, right, op) ::= <<
(left op right)
>>

unaryOp(op, operand) ::= <<
(op operand)
>>

simpleStatement(statement) ::= <<
<statement>;

>>

functionCall(function, args) ::= <<
<function>(<args; separator=", ">)
>>

parStatement() ::= <<

>>