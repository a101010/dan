group SingleThread;

danModule(frontMatter, imports, decs) ::= <<
// C file generated from Danger source code by the dan compiler
<frontMatter>

#include \<stdio.h\> // TODO write string, logging, and io libs for Danger
#include \<time.h\>  // TODO write a time lib for Danger
#include \<__struntime.h\>

// ---------------------------------------
// I m p o r t s
// ---------------------------------------
<imports>

// ---------------------------------------
// D e c l a r a t i o n s
// ---------------------------------------

<decs>
>>

importStmt(library, symbol) ::= <<
// import: library= <library> symbol= <symbol>

>>

attrib(attribId) ::= <<
// [<attribId>]

>>

adornedDec(attribs, dec) ::= <<

// -------------------------------------
// Adorned declaration
// -------------------------------------
// Attribute section:
<attribs>
<dec>

>>

simpleBundleDec(bundleType, 
                channelDeclarations,
                channelConstructors,
                readEnds,
                writeEnds) ::= <<
// ----------------------------------------------
// <bundleType> channel bundle type

typedef struct BundleR_<bundleType>_tag
{
    <readEnds>
} BundleR_<bundleType>;

typedef struct BundleW_<bundleType>_tag
{
    <writeEnds>
} BundleW_<bundleType>;

// backing store for <bundleType> channel bundle
typedef struct Bundle_<bundleType>_tag
{

    BundleR_<bundleType>   *read;
    BundleW_<bundleType>   *write;
    BundleR_<bundleType>   readStore;
    BundleW_<bundleType>   writeStore;
    <channelDeclarations>
} Bundle_<bundleType>;



// <bundleType>_chans constructor
Bundle_<bundleType> * Bundle_<bundleType>_ctor(Bundle_<bundleType> * chans)
{
    <channelConstructors>
    chans->read = &(chans->readStore);
    chans->write = &(chans->writeStore);
    return chans;
}


// End of <bundleType> bundle type


>>



procDec(procType,
        locals,
        params,
        args,
        initLocals,
        procBodyScratchInit,
        statements,
        cleanup) ::= <<
// ----------------------------------------------
// <procType> PROC type
typedef struct <procType>_locals_tag
{
	<locals>
} <procType>_locals;

typedef struct <procType>_proc_tag
{
    proc                        p;
    <procType>_locals           locals;
} <procType>_proc;

// <procType>_locals constructor
<procType>_locals * <procType>_locals_ctor(<procType>_locals * locals,
    <params; separator=", ">)
{
  <initLocals>
}

void <procType>_body(proc * ap, scheduler * s)
{
    <procBodyScratchInit>
	
    <procType>_proc* p = (<procType>_proc*) ap;
	<procType>_locals* locals = &(p->locals);
    if(ap->state != _PS_READY_TO_RUN_)
        restoreState(ap->state);

    <statements>
	
    ap->state = _PS_CLEAN_EXIT_;
EXIT:
    if((ap->state == _PS_EXCEPTION_) || (ap->state == _PS_CLEAN_EXIT_) )
    {
        <cleanup>
    }
}

// End of <procType> PROC type


>>

procDecLite(procType, returnType, params, statements) ::= <<
// TODO use procDecLite for procs that don't have par, fork, or do channel comms
// <returnType> <procType>(<params; separator=", ">)
/* 
    <statements>
*/

>>

defaultCleanup(type, name) ::= <<
// don't need to cleanup <name> of type <type>

>>

bundleEndCleanup(type, name) ::= <<
locals-><name>->poison(locals-><name>->chans, s);

>>

bundleCleanup(type, name) ::= <<
Poison_<type>(&<name>, s);

>>

localValueDec(type, name) ::= <<
<type> <name>;

>>

localByRefDec(type, name) ::= <<
<type> *<name>;

>>

initLocal(name, value) ::= <<
locals-><name> = <value>; 

>>


constructLocal(type) ::= <<
// TODO construct local <type>

>>



valueParam(type, name) ::= "<type> <name>"

refParam(type, name) ::= "<type> *<name>"


ifStatement(condition, statements) ::= <<
if ( <condition> )
{
    <statements>
}

>>

elseIfStatement(condition, statements) ::= <<
else if ( <condition> )
{
    <statements>
}

>>

elseStatement(condition, statements) ::= <<
else
{
    <statments>
}

>>

whileStatement(condition, statements) ::= <<
while (<condition>)
{
    <statements>
}

>>

receiveStatement(procType, chanr, target, labelNum, targetCleanup) ::= <<
<targetCleanup>
saveState(ap->state, <procType>_S<labelNum>);
<target> = locals-><chanr>->read( locals-><chanr>->channel, &(locals-><target>), &ap->exception, ap, s);
switch(result)
{
case 0 : // read value
    printf("<procType>: read value %d from <chanr>\n", locals-><target>);
    break;
case 1 : // blocked
    // let it read again
    goto EXIT;
case 2 : // exception
    ap->state = _PS_EXCEPTION_;
    goto EXIT;
default:
    printf("unexpected result from read on <chanr> in <procType>_body: %d\n", result);
    ap->state = _PS_EXCEPTION_;
    ap->exception = "unexpected result from read on <chanr> in <procType>_body";
    goto EXIT;
}

>>

sendStatement(procType, chanw, source, labelNum, sourceCleanup) ::= <<
result = locals-><chanw>->write( locals-><chanw>->channel, locals-><source>, (void **) &ap->exception, ap, s);
switch(result)
{
case 0 : // wrote value
    printf("<procType>: wrote <source> to <chanw>\n", locals-><source>);
    break;
case 1 : // blocked
    saveState(ap->state, <procType>_S<labelNum>);
    if(result == 1)
        goto EXIT;
    result = locals-><chanw>->writeHandshake( locals-><chanw>->channel, (void **) &ap->exception, ap, s);
    switch(result)
    {
    case 0 : // wrote value
        printf("<procType>: wrote <source> to <chanw>\n", locals-><source>);
        break;
    case 1 : // blocked
        goto EXIT;
    case 2 : // exception
        p->state = _PS_EXCEPTION_;
        goto EXIT;
    default:
        printf("unexpected result from write to <chanw> in <procType>_body: %d\n", result);
        ap->state = _PS_EXCEPTION_;
        ap->exception = "unexpected result from write to <chanw> in <procType>_body";
        goto EXIT;
    }
    break;
case 2 : // exception
    ap->state = _PS_EXCEPTION_;
    goto EXIT;
default:
    printf("unexpected result from write to <chanw> in <procType>_body: %d\n", result);
    ap->state = _PS_EXCEPTION_;
    ap->exception = "unexpected result from write to <chanw> in <procType>_body";
    goto EXIT;
}
<sourceCleanup>

>>

assignmentStatement(target, targetCleanup, source) ::= <<
locals-><target> = <source>;
<targetCleanup>

>>

binaryOp(left, right, op) ::= <<
(left op right)
>>

unaryOp(op, operand) ::= <<
(op operand)
>>

simpleStatement(statement) ::= <<
<statement>;

>>

functionCall(function, args) ::= <<
<function>(<args; separator=", ">)
>>

parStatement() ::= <<

>>

genericTypeId(id, ga) ::= <<
<id>\<<ga; separator=", ">\>
>>

typeId(id) ::= <<
<id>
>>

param(type, name) ::= <<
<type> <name>
>>

genericArgList(args) ::= <<
<args>
>>

paramList(params) ::= <<
<params>
>>